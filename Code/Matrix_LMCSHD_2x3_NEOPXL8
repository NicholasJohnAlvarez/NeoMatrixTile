// =============================================================
// 12/1/25 - Dig-Octa 3x2 Matrix (48x32) Faster Refresh (NeoPXL8)
// Converted from FastLED to Adafruit NeoPXL8 for true parallel
// 6× 16x16 WS2812 panels = 1536 LEDs total
// Partially Generated by Chat GBT 
// =============================================================

#include <Adafruit_NeoPixel.h>
#include <Adafruit_NeoPXL8.h>

#define NUM_PANELS 6
#define PANEL_W 16
#define PANEL_H 16
#define PANEL_LEDS (PANEL_W * PANEL_H)

#define TOTAL_LEDS (NUM_PANELS * PANEL_LEDS)
#define BRIGHTNESS 30

// Dig-Octa Channel pins 1–6 (remaining 2 unused but required)
int8_t dataPins[8] = { 1, 2, 3, 4, 5, 6, -1, -1 };

// Combined LED buffer
Adafruit_NeoPXL8 leds(TOTAL_LEDS, dataPins, NEO_GRB);

// Virtual 48x32 RGB565 canvas (3072 bytes)
uint16_t canvas[48 * 32];

void setup() {
  Serial.begin(2000000);          // LMCSHD protocol
  leds.begin();
  leds.setBrightness(BRIGHTNESS);

  Serial.println("Dig-Octa 3x2 Matrix Ready (NeoPXL8 Parallel)");
}

void loop() {

  uint8_t cmd = Serial.read();

  // ========================
  // 0x05 → Query dimensions
  // ========================
  if (cmd == 0x05) {
    Serial.println(48);
    Serial.println(32);
    return;
  }

  // ========================
  // 0x42 → Frame incoming
  // ========================
  if (cmd == 0x42) {

    // Read full RGB565 frame
    Serial.readBytes((uint8_t*)canvas, 48 * 32 * 2);

    // Byte-swap RGB565 (network → little endian)
    for (int i = 0; i < 48 * 32; i++) {
      canvas[i] = (canvas[i] << 8) | (canvas[i] >> 8);
    }

    // Map canvas → NeoPXL8 LED buffer
    mapCanvasToPanels();

    // Single parallel refresh!
    leds.show();

    // Acknowledge frame
    Serial.write(0x06);
  }
}


// =============================================================
// Map virtual 48×32 → 6 physical 16×16 panels (zig-zag layout)
// =============================================================
void mapCanvasToPanels() {
  // Panel layout:
  //
  // Row 0: P0 (0,0) → P1 (16,0) → P2 (32,0)
  // Row 1: P5 (0,16) ← P4 (16,16) ← P3 (32,16)
  //
  // Each panel is 256 LEDs sequentially in NeoPXL8 buffer:
  // Panel N = leds[offset + 0 … 255]
  //
  // offset = N * 256
  //

  copyPanel(0,  0,  0);   // Panel 0
  copyPanel(16, 0,  1);   // Panel 1
  copyPanel(32, 0,  2);   // Panel 2

  copyPanel(32,16, 3, true); // Panel 3 (mirrored rows)
  copyPanel(16,16, 4, true); // Panel 4 (mirrored rows)

  copyPanel(0, 16, 5);       // Panel 5
}


// =============================================================
// Copy 16×16 block from canvas into panel buffer
// Handles optional zig-zag X reversal
// =============================================================
void copyPanel(int x0, int y0, int panelId, bool zigzag = false) {

  int offset = panelId * PANEL_LEDS;  // Starting LED index for panel

  for (int y = 0; y < 16; y++) {
    for (int x = 0; x < 16; x++) {

      int cx = x0 + (zigzag ? (15 - x) : x);
      int cy = y0 + y;
      int cIndex = cy * 48 + cx;

      uint16_t rgb565 = canvas[cIndex];

      // Convert RGB565 → 8-bit GRB
      uint8_t r = ((rgb565 >> 11) & 0x1F) << 3;
      uint8_t g = ((rgb565 >> 5)  & 0x3F) << 2;
      uint8_t b = ((rgb565 >> 0)  & 0x1F) << 3;

      int ledIndex = offset + (y * 16 + x);  // panel-relative
      leds.setPixelColor(ledIndex, r, g, b);
    }
  }
}